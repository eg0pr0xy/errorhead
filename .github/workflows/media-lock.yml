name: Media Import Lock

on:
  pull_request:
    branches: [ main ]

jobs:
  verify-shared-entry:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Verify single shared media entry contract
        run: |
          set -euo pipefail
          echo "Checking App.tsx for single handler and calls"
          grep -E -n "const\s+handleFileSelect\s*=\s*\(file:\s*File\)" App.tsx
          grep -E -n "file\.type\.startsWith\('video/'\)" App.tsx
          grep -E -n "loadVideoTo\(videoRef\.current,\s*canvasRef\.current,\s*file,\s*lastObjectUrlRef\)" App.tsx
          grep -E -n "loadImageTo\(imgRef\.current,\s*canvasRef\.current,\s*file,\s*lastObjectUrlRef\)" App.tsx

          echo "Checking hidden source elements"
          grep -E -n "<img\s+ref=\{imgRef\}" App.tsx
          grep -E -n "<video\s+ref=\{videoRef\}" App.tsx

          echo "Checking loaders for original ready hooks"
          grep -E -n "img\.onload\s*=\s*" media_loader/mediaLoader.ts
          grep -E -n "video\.onloadedmetadata\s*=\s*" media_loader/mediaLoader.ts

      - name: Enforce no multi-event finish flows in loader (lock)
        run: |
          set -euo pipefail
          echo "Ensuring no forbidden patterns in media loader"
          # These patterns previously caused regressions by racing dimension readiness.
          if grep -E -n "(loadeddata|canplay)" media_loader/mediaLoader.ts; then
            echo "Forbidden event handler detected in media loader" && exit 1
          fi
          if grep -E -n "addEventListener\s*\(\s*'(loaded|canplay)" media_loader/mediaLoader.ts; then
            echo "Forbidden addEventListener for media readiness detected" && exit 1
          fi
          if grep -E -n "function\s+finish\s*\(|const\s+finish\s*=\s*\(" media_loader/mediaLoader.ts; then
            echo "Forbidden finish() aggregator detected in loader" && exit 1
          fi

      - name: Lock boundaries — only App.tsx may import media loader
        run: |
          set -euo pipefail
          echo "Checking that only App.tsx imports media_loader/mediaLoader"
          IMPORTS=$(rg -n "from './media_loader/mediaLoader'" -S | wc -l)
          if [ "$IMPORTS" -ne 1 ]; then
            echo "Expected exactly 1 import site for media loader, found $IMPORTS" && rg -n "from './media_loader/mediaLoader'" -S && exit 1
          fi
          # Ensure that single import is in App.tsx
          if ! rg -n "from './media_loader/mediaLoader'" -S App.tsx >/dev/null; then
            echo "media loader must only be imported in App.tsx" && exit 1
          fi

      - name: Lock boundaries — forbid media loader in services/effects
        run: |
          set -euo pipefail
          if rg -n "media_loader/mediaLoader" -S services glitch_ops datamosh_ops engine frame_pipeline >/dev/null; then
            echo "Forbidden media loader import detected outside App.tsx" && rg -n "media_loader/mediaLoader" -S services glitch_ops datamosh_ops engine frame_pipeline && exit 1
          fi

      - name: Lock boundaries — forbid media element creation in effects/services
        run: |
          set -euo pipefail
          # Disallow creating <img>/<video> elements or using Image constructor outside App/media_loader
          if rg -n "new\s+Image\s*\(" -S services glitch_ops datamosh_ops engine frame_pipeline >/dev/null; then
            echo "Forbidden new Image() outside media core" && rg -n "new\s+Image\s*\(" -S services glitch_ops datamosh_ops engine frame_pipeline && exit 1
          fi
          if rg -n "document\.createElement\(\s*['\"](img|video)['\"]\s*\)" -S services glitch_ops datamosh_ops engine frame_pipeline >/dev/null; then
            echo "Forbidden document.createElement(img|video) outside media core" && rg -n "document\.createElement\(\s*['\"](img|video)['\"]\s*\)" -S services glitch_ops datamosh_ops engine frame_pipeline && exit 1
          fi
          # Disallow URL.createObjectURL outside App/media_loader
          if rg -n "URL\.createObjectURL\(" -S services glitch_ops datamosh_ops engine frame_pipeline >/dev/null; then
            echo "Forbidden URL.createObjectURL outside media core" && rg -n "URL\.createObjectURL\(" -S services glitch_ops datamosh_ops engine frame_pipeline && exit 1
          fi

      - name: Lock boundaries — single render entry
        run: |
          set -euo pipefail
          echo "Ensuring renderGlitch is only invoked from App.tsx"
          if rg -n "renderGlitch\(" -S | grep -v "App.tsx:" >/dev/null; then
            echo "renderGlitch must only be called from App.tsx" && rg -n "renderGlitch\(" -S && exit 1
          fi

      - name: Verify file input routes into handler
        run: |
          set -euo pipefail
          grep -E -n "onChange=\{\(e\)\s*=>\s*\{[\s\S]*onFileSelect\(f\)" components/Panels/FilePanel.tsx
